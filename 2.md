## Работа с кучей на C++

### New / delete
`new` и `delete` можно рассматривать как аналоги `malloc` и `free`
Но `new` и `delete` - операторы, их транслирует компилятор, а не линкуется из библиотеки

Функции `malloc` / `free` не знают про конструктор и деструктор, а отличие от `new` / `delete`:
* ```new``` пытается выделить память указанного размера, а затем пытается создать и инициализировать либо объект при помощи конструктора по умолчанию.
* ```delete[]``` проходит по памяти и у каждого объекта вызвать деструктор
* ```delete``` вызывает деструктор 

```c++
int* pi = new int[5];
my_class* a = new my_class;
delete[] a;
delete my_class
```
### Создание объектов на куче
`new` и `delete` вызывают конструкторы и деструкторы классов соответственно. 
При создании массива через `new` не стоит удалять без `[]`, может `UB`.

### Конструктор копий
Конструктор копий используется, когда нужен оператор присваивания.
Есть один объект нашего класса, мы хотим проинициализировать новый с такими же значениями полей.

По умолчанию у объектов произойдет побайтовое копирование полей. 
Это может плохо сказаться, т.к. может быть так, что два поля будут 
указывать на одно место в памяти, и при завершении функции вызовется
деструктор два раза на один участок памяти.

Напишем пример конструктора копий:
### Оператор присваивания
Рассмотрим следующую ситуацию: мы хотим присвоить два объекта, а потом присвоить первому второй. Для этого можно определить оператор "=".

Воспользуемся swap-and-copy idiom:
```c++
Array& operator=(const Array& other) {
    std::swap(_data, other._data);
    return *this;
}
```
### C++11: =delete
Объявление удаленной функции — это форма 
объявления функции, представленная в стандарте `C++11`. 
Чтобы объявить функцию удаленной, вы можете добавить 
`=delete`;спецификатор в конец объявления этой функции.
Компилятор отключает использование удаленной функции.

Мы можем объявить неявно определенную функцию как удаленную,
если хотим предотвратить ее использование.  