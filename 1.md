## Классы и объекты

### Инкапсуляция: private / public

Три основные идеи ООП:
* Инкапсуляция
* Полиморфизм
* Наследование

**Инкапсуляция** - это механизм языка, позволяющий ограничить доступ одних компонентов программы к другим

Инкапсуляция позволяет работать с кодом, как с черным ящиком.

При работе без этого программисту нужно не забыть создать, не выйти за границы, не перепутать размер, не забыть удалить. Если за это отвечает некоторый интерфейс, можно не думать о его реализации.

Если нужно поменять класс, можно унаследовать новый класс от старого и добавить / удалить что-то


В классе есть 3 модификатора доступа: private / public / protected:
* Public функции доступны всем, изменять public переменные тоже может кто угодно
* Private поля могут изменять только представители класс
* Protected поля могут изменять только представителя класса и его наследники

Проверка на соответствие модификатора и использования происходит во время компиляции

### Конструктор (overloading), деструктор

Поговорим про перегрузку: можно
создать несколько функций с одним
именем, но разными параметрами, 
при этом линкер их сможет различить: 
во время компиляции им 
присваиваются новые имена 
(name mangling):

В C++ можно так:
```c++
int max(int a, int b) {...}

int max(int a, int b, int c) {...}
```

Посмотрим примерную картину, что увидел бы линкер:
* В C (примерно):
```c
max(int a, int b) {...} ----> max
max(int a, int b, int c) {...} ----> max
```

* В C++ (примерно):
```c++
max(int a, int b) {...} ----> max_int_int
max(int a, int b, int c) {...} ----> max_int_int_int
```

То есть можно, например, сделать два конструктора

А для чего вообще конструкторы? Конструкторы нужны, чтобы инициализировать поля. Так же может определяться конструктор по умолчанию (default constructor):
```c++
class Array {
public:
    Array(int size) { _size = size; data = new int[_size]; }
    Array() { _size = 100; data = new int[_size]; }
private:
    int _size;
    int *data;
};
```

По умолчанию инициализируются пустые конструктор и деструктор.

### Деструктор
Деструктор вызывается автоматически, когда объект выходит из области видимости. Для класса можно написать свой деструктор:
```c++
class Array {
public:
    ~Array() {
        std::cout << "Destructor called" << std::endl;
    }
};
```

## Инициализация полей

Все поля инициализированы чем-то до конструктора. Инициализация может происходить через двоеточие после конструктора.
Такой метод позволяет избежать коллизии имен и проинициализировать ссылки:
```c++
Array::Array(int size): _size(size);
```
