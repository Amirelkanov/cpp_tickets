## Приведение типов

### C-style cast, `static_cast`, `const_cast`, `reinterpret_cast` - поведение и преимущества

Вспомним про приведения типов в C:
* Неявное приведение (может вызвать warning, но не error):
```c++
    int a = 65535; // Число гораздо больше, чем char в себя вмещает, поэтому мы неявно приведем
    char b = a;
```

```c++
int c = 3.5 // Тоже неявное приведение типов
```
* Явное приведение ("То, что написано в коде, неслучайно - я так действительно хочу"):
```c++
int a = 5; int b = 6;
double c = a / (double) b
```

Теперь поговорим приведения в C++:
Явное приведение требуется для указателей (кроме к `void*` и приведения к базовому классу)
```c++
void* f() {...}

int* pi = (int*) f(); // По-другому не даст, нужно приведение
```

Пример приведения для классов:
```c++
class BigInt {
    BigInt(int a); // int ----> BigInt
    operator int(); // BigInt ----> int
};
```

Заметим, что `explicit` запрещает неявное приведение.

Явное приведение упрощает поиск в коде и более точно выражает намерение программиста:
* Разные cast'ы для разных случаев
* Компилятор делает более точную проверку

Поговорим про cast'ы:
* `static_cast`. Чаще всего используется для преобразования примитивных типов данных: классов, связанных с наследованием; приведению к `void`; пользовательские преобразования (как у нас `BigInt -> Int`)
```c++
int a = 65535;
char b = static_cast<char>(a);
```

* `reinterpret_cast` (довольно небезопасно).
  * Используется для преобразования указателя некоторого типа данных в указатель другого типа данных,
  даже если типы данных до и после преобразования различны.
  * Не проверяет, совпадают ли тип указателя и данные, на которые указывает указатель, или нет.
```c++
void* f();
int* pi = reinterpret_cast<int*>(f());
```

* `const_cast` (лучше не использовать). Добавление и удаление `const`:
```c++
char const *p1 = "Hello";
char *p2 = const_cat<char*>(p1);
p2[0] = 'h'; // UB
```

### `RTTI`  и `dynamic_cast`

Поговорим про технологию `RTTI` (`Run-Time Type Information`). Это что-то наподобие `Reflection` в Kotlin.

* Оператор `dynamic_cast` осуществляет безопасное преобразование указателя на базовый класс в указатель на производный класс (ну или ссылки на производный класс)
* Оператор `typeid` возвращает фактический тип объекта для указателя (ну или же ссылки)

Рассмотрим следующий пример:
```c++
class A {...};

class B: public class A {...};
class C: public class A {...};
```

```c++
void do_sth(B *b);

A *a = new C();
f(static_cast<B*>(a));
```

Мы создали объект класса `C`, который наследник `A`. Затем сделали каст к `B*`, 
и компилятор не видит ничего подозрительного: `B` - тоже наследник `A`, что может пойти не так?

Теперь засунем нашу кастанутую переменную в функцию, использующую `B*`. `B` - конечно, наследник `A`, как и `C`, но у него могут быть свои уникальные поля и переменные, которых нет у `C`. 
Тогда во время runtime'а все это выльется в UB. Что же делать?

На помощь нам приходит `dynamic_cast`: он заглядывает в таблицу виртуальных функций и смотрит, действительно ли `a` - это `A*`, а не `C*`, как у нас.
Если нет, то он вернет 0, если да, то все хорошо:
```c++
if (dynamic_cast<B*>(a) != 0) {
    f(static_cast<B*>(a);
}
```

* RTTI работает для классов с виртуальными функциями, т.к. информация о типе хранится в таблице виртуальных функций
* RTTI чаще всего используется, когда нужно сделать костыль для существующего кода, который нельзя переделать:
Представим себе ситуацию: есть у нас приложение для отрисовки различных фигур. У них у всех есть метод `draw()`.
Но тут мы решили добавить анимацию к некоторым фигурам, 
а значит нужно и сделать новую отрисовку `animated_draw()`, 
но нам не представляется возможным переписывать все с нуля. Тогда можем 
воспользоваться RTTI:
```c++
class Shape {
    virtual draw() = 0;
};

.
.
.

draw_all(Shape* shapes, size_t n) {
    for (size_t i = 0; i < n; i++) {
        Shape* p = shapes[i];
        p->draw();
        if (dynamic_cast<AnimatedShape*>(p) != 0) {
            p->animated_draw(); // У обычного Shape такого метода нет, но есть у Animated
        }
    }
}
```

Важно так же упомянуть и `typeid`. Опять же, похоже на Reflection:
```c++
#include <typeinfo>

A *a = new C(); 
type_info ti = typeid(*a);
ti.name(); // Выведет C
```