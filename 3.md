## Наследование и полиморфизм

Наследование - создание класса на основе другого, при этом производный 
класс будет иметь те же методы, но 
возможно добавлять новые поля, методы, переопределять или дописывать старые

Полиморфизм - возможность сделать объект базового типа объектом 
производных типов, а также возможность переписать / дописать методы базового в производном

### `protected`
`protected` позволяет видеть содержимое не только представителям класса, но 
и всем наследникам. Это позволяет использовать поля и методы родителя в классах 
наследниках, которые при этом не должны быть публичными.

### `virtual` (overriding)

Виртуальные функции нужны для того, чтобы они были переписаны у детей.
Это требуется для того чтобы программа понимала, какую функцию нужно вызывать при работе.

Конструктор не может быть виртуальным, но деструктор может. Если виртуальная функция объявлена с `=0`, то можно провести аналогию с 
`abstract`-функциями, т.е. она должны быть перекрыта в дочернем классе, а в родительском - реализации быть не должно.

Приведем пример:

```c++
list.h:

class List {
protected:
    int val;
    List *next;
public:    
    List(int val);
    ~List();
    virtual void push_back(int val);
    size_t get_length() const;
};
```

```c++
double_list.h:

#include "list.h"
class DoubleList: public List {
private:
    DoubleList *prev;
public:
    DoubleList(int val);
    ~DoubleList();
    void push_back(int val);
    void pop_back(); // New method
};
```

DoubleList "умеет" все, что умеет List с точки зрения интерфейса, т.е. поддерживает те же публичные функции. 

Обратное неверно, т.к. у DoubleList есть уникальный метод `pop_back`
### Статическое / динамическое связывание

В данном контексте "связывание" - это сопоставление имени функции и ее адреса в памяти.

* Статическое связывание - имя можно заменить не адрес на этапе построения программы:
```c++
Sale s(...); // Сразу создали объект и засунули его в переменную
int r = s.getSalary()
```
* Динамическое связывание - имя можно заменить на адрес только на этапе выполнения программы:
```c++
Worker *w;
int d;
std::cin >> d;
if (d > 0) {w = new Developer(...);}
else {w = new Sale(...);}
w->getSalary();
```

По умолчанию в С++ используется статическое связывание

Если у метода задано ключевое слово virtual, то для него используется динамическое связывание:
```c++
class Worker {
    ...
    virtual int getSalary() = 0 const;
    virtual ~Sale() {...}
};
```

А как же при динамическом связывании происходит выбор нужной функции? С помощью таблицы виртуальных функций!

### Таблица виртуальных функций

При старте программы для каждого класса с виртуальными методами создается таблица, в которой задано соответствие между именем функции и ее адресом в памяти (указатель на функцию)

Каждый объект класса с виртуальными функциями хранит указатель (скрытое поле vptr) на начало таблицы виртуальных функций своего класса

В месте вызова виртуальной функции компилятор генерирует следующий код:
* Пойди по адресу `vptr`
* Найди в таблице функцию с нужным именем
* Считай из таблицы адрес функции и перейди на нее

Вызов функции со статическим связыванием будет быстрее вызова с динамическим, т.к. в первом случае будет просто переход на память, а во втором - нужно проделать алгоритм в runtime'е, описанный выше (примерно)
