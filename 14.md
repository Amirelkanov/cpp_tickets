Контейнеры - это структуры данных для хранения объектов в памяти: вектор, список, ассоциативный массив, ...

Требования к хранимым объектам:

* Корректно работает конструктор копий (copy-constructable)
* Корректно работает оператор присваивания (assignable)

Методы, которые есть у всех контейнеров:

* Конструктор по умолчанию, конструктор копирования, оператор присваивания, деструктор
* Операторы сравнения: `==, !=, >, >=, <, <=`
* Методы `size(), empty()`
* Метод `swap(obj2)`
* Методы `insert(...), erase(...)`
* Метод `clear()`
* Методы `begin(), end()` - первый и последний элемент (должны быть по-хорошему)

## Ассоциативные контейнеры

* Ассоциативные контейнеры переупорядочивают элементы для быстрого поиска `O(log n)` (к примеру, бин. поиск)
* Реализуются, к примеру, бин. деревом поиска

Особенности:

* Требуют отношение порядка: для элементов должен быть определен `operator<(...)`
* Нет произвольного доступа по индексу

Рассмотрим обязательные методы для ассоциативных контейнеров:

* Конструктор по умолчанию, конструктор копирования, оператор присваивания, деструктор
* `begin(), end()`
* Операторы сравнения: `==, !=, >, >=, <, <=`
* `size(), empty()`
* `swap(obj2)`
* `clear()`

Рассмотрим общие методы для ассоциативных контейнеров:

* `erase` по какому-то key
* `insert` / `insert` с подсказкой (итератор)
* `count` - подсчитать число элементов с заданным key
* `find` - поиск на точное совпадение (возвращает итератор)
* `lower_bound()` / `upper_bound() / `equal_range` - возвращает итератор на первый элемент не меньше / не больше / равно
  key

### `set`, `multiset`, `map`, `multimap`

* В `set` элементы являются уникальными, в `multiset` дубликаты допустимы
* Реализуются бинарным деревом поиска, в вершине находится key:

```c++
#include <set>

std::set<int> s;
s.insert(10);
s.insert(20);
s.insert(10);

// Пытаемся еще раз добавить 10, но в set не может содержаться несколько одинаковых объектов, 
// поэтому 10 еще раз не добавляется. 
// В данный момент s.size() == 2

std::multiset<int> ms;;
ms.insert(1);
ms.insert(2);
ms.insert(2);
// ms.size() == 3
```

Понятно, что порядок не сохраняется:

```c++
std::set<int> s;
s.insert(10);
s.insert(12);
s.insert(29);
s.insert(5);
s.insert(1);
```

`s` выглядит так: `{1, 5, 10, 12, 29}`

Заметим, что изменить добавленный элемент нельзя, т.к. если изменить значение в вершине дерева поиска, то нарушится
порядок:

```c++
std::set<int> s;
s.insert(10);
std::set<int>::iterator it = s.find(10);
*it = 5; // НО МЫ НЕ СМОЖЕМ, Т.К. ПРИСВАИВАНИЕ ЗАПРЕЩЕНО!!!
```

* `map` - элементы являются уникальными, а в `multimap` дубликаты допустимы
* Оба контейнера реализуются бинарным деревом поиска, в вершине хранится пара: `(key, value)`

Вспомогательный класс `pair` выглядит примерно так:

```c++
template<class F, class S>
struct pair {
    F first;
    S second;
    ... // Конструкторы
};

template<class F, class S>
pair<F, S> make_pair(F const& f, S const& s);

template<class Key, class T, ...> class map {
    ...
    typedef pair<const Key, T> value_type;
};
```

Приведем пример использования:

```c++
std::map<string, int> phonebook;
phonebook.insert(std::pair<string, int> ("Mary", 12345678);
phonebook.insert(std::pair<string, int> ("Alex", 1212346);
phonebook.insert(std::pair<string, int> ("Bob", 1223238);

std::map<std::string, int>::iterator it = phonebook.find("John");
if (it != phonebook.end()) {
    std::cout << "John's phone number is " << it->second << std::endl;
}
for (it = phonebook.begin(); it != phonebook.end(); ++it) {
    std::cout << it->first << ": " << it->second << "\n";
}
```

Особые методы: `operator[]` с небольшим замечанием: он работает только с неконстантными map, а также требует наличие
конструктора по умолчанию у T:

```c++
T& operator[] (Key const& k) {
    iterator i = find(k);
    if (i == end()) {
        i = insert(k, T());
    }
    return i->second;
 }
```

Данный оператор требует `O(log n)` времени (т.к. бин. поиск). Следовательно, не стоит работать с map как с массивом.

Приведем пример использования:

```c++
m["vasya"] = 10;
m["petya"] = 20;
int p = m["kolya"] // Если такого ключа нет, то будет создан новый элемент ("kolya", 0)
```

### `unordered_set`, `unordered_map`

Поймем, как примерно устроен `unordered_map`:
Сами данные хранятся в векторе списков. В каждом блоке компаратор определяет, упорядочена ли каждая пара элементов
должным образом. Когда нужно вставить элемент, то от индекса рассчитывается хеш.

По полученному хешу находится элемент вектора (нужный список), в который и добавляется наш элемент (предварительно
проверяется, а нет ли такого элемента езе)

Функция итерации делается по простому - проходимся по всем элементам вектора и выводим элементы списка в естественном
порядке.

* Операции `find` / `delete` в среднем выполняются за `O(1)`, но в худшем случае - все элементы в одном блоке - будет
  работать за `O(n)`
* Кроме того, вставка элементов не делает итераторы недействительными, а при удалении элементов недействительными
  становятся только итераторы, указывающие на удаленный элемент.

```c++
template < class Key, 
           class Hash = std::hash<Key>,
           class KeyEqual = std::equal_to<Key>,
           class Allocator = std::allocator<Key> >
class unordered_set;
```

Хеш-функцию для своего класса мы должны написать сами. Приведем пример использования:

```c++
class Point {
private:
    int x, y;
private:
    bool operator == (const Point& other) const {
        return x == other.x && y == other.y
    } 
};

namespace std {
    template<>
    struct hash<Point> {
        size_t operator() (Point const& p) const  {
            return (std::hash<int>()(p.getX()) * 53 + std::hash<int>()(p.getY())) * 239;
        }
    };
}

std::unordered_set<Point> points;
```

### Итераторы и их инвалидация

Итераторы - объекты, которые синтаксически ведут себя как указатель (определены операторы `++`, `-`, `*`, `->`)

Универсальный способ перебора элементов контейнеров в STL - перебор с помощью итератора

Итераторы реализованы как вложенные классы для контейнеров.

Все контейнеры имеют функции, которые возвращают итераторы на первый элемент и на элемент, следующий за последним.

Приведем пример: поудаляем все пары со значением 0:

```c++
std::map<string, int> m;
std::map<string, int>::iterator it = m.begin();


// НЕПРАВИЛЬНЫЙ ВАРИАНТ!!!!!!!!!! СЛОМАЕТСЯ ИТЕРАТОР!!!!!!
for (; it != m.end(); ++it) {
    if (it->second == 0) {
        m.erase(it);
    }
}

for (; it != m.end(); ) {
    if (it->second == 0) m.erase(it++);
    else ++it;
}
    
```