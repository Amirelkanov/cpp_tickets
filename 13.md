Контейнеры - это структуры данных для хранения объектов в памяти: вектор, список, ассоциативный массив, ...

Требования к хранимым объектам:
* Корректно работает конструктор копий (copy-constructable)
* Корректно работает оператор присваивания (assignable)

Методы, которые есть у всех контейнеров:
* Конструктор по умолчанию, конструктор копирования, оператор присваивания, деструктор
* Операторы сравнения: `==, !=, >, >=, <, <=`
* Методы `size(), empty()`
* Метод `swap(obj2)`
* Методы `insert(...), erase(...)`
* Метод `clear()`
* Методы `begin(), end()` - первый и последний элемент (должны быть по-хорошему)

## Последовательные контейнеры

В чем особенность последовательных контейнеров?
* Сохраняют порядок, в котором были добавлены элементы
* Есть добавление в конец при помощи метода `push_back`


### `vector`, `string`, `list`, `string_view`. Внутреннее устройство и основные операции

* `std::vector` - динамический массив с автоматическим изменением размера при добавлении элеметнов:
  * Для уменьшения количества вызовов `new` при добавлении память выделяется с запасом (примерно в 2 раза больше чем size)
  * У `vector` есть текущий размер и вместительность: `size` и `capacity`
  * Сложность добавления элемента в конец вектора и удаления элемента из конца - в среднем, `O(1)`
  * Сложность добавления элемента или его удаления из начала или середины вектора - `O(n)`
  * Сложность доступа к элементу по индексу - `O(1)`
Поговорим про его методы:
  * `size() / resize()` - добавление элементов
  * `capacity() / reserve()` - управление зарезервированной памятью
  * `push_back() / pop_back()` - добавление / удаление последнего
  * `operator[], at()` - `at` бросает исключения при выходе за границы
  * `data()` - указатель на массив (для "устаревших" функций)
Приведем пример его использования:
```c++
#include <vector>
std::vector<int> v;
v.push_back(10);
v.pop_back();
v[0] = 13;
v.at(0) = 14;
size_t size = v.size();
bool is_empty = v.empty();
v.clear();
v.resize(10);
v.resize(20, 5); // Добавленные при увеличении размера элементы будут равны 5 (такой метод работает только, если есть конструктор по умолчанию)
int *dst = new ...; 
memcpy(dst, v.data(), v.size()) // Вот и пример использования data()
v.reserve(100) // Резервирование памяти под 100 элементов
```

* `std::deque` - двусторонняя очередь. Контейнер с возможностью быстрой вставки и удаления элементах на обоих концах
за амортизированное `O(1)`. Реализован как массив указателей на массивы фиксированного размера

Рассмотрим ее методы:
* `size() / resize()`
* `operator[], at()`
* `push_back(), push_front()`
* `pop_back(), pop_front()`

* `std::list` - двусвязный список (текущая нода знает, кто сзади и кто спереди него). В любом месте контейнера вставка и удаление производятся за `O(1)`
Нет обращения по индексу.

Рассмотрим его методы:
* `size() / resize()`
* `push_back(), push_front()`
* `pop_back(), pop_front()`
* `merge(), splice()`

* `std::string` - контейнер для хранения символьных последовательностей.
  * Есть метод `c_str()` для совместимости со старым кодом:
```c++
    std::string res = "Hello";
    printf("%s", res.c_str());
  ```
  * Множество алгоритмов вроде `substr(), find()`
  * Поддержка преобразований типа с C строками:
```c++
f(const std::string& s);
f("hello");
```
  * `append, operator+, operator+=`
  * `string = basic_string<char>`
  * `wstring = basic_string<wchar_t>` - для работы с длинными символами
  
### Итераторы и их инвалидация

Итераторы - объекты, которые синтаксически ведут себя как указатель (определены операторы `++`, `-`, `*`, `->`)

Универсальный способ перебора элементов контейнеров в STL - перебор с помощью итератора

Итераторы реализованы как вложенные классы для контейнеров:
```c++
class vector {
    ...
    class iterator {
        T* ptr
        operator ++() { ptr++; }
    };
};

vector::iterator it1; // Завели итератор

class list {
    class iterator {
        Node<T> ptr;
        operator++() { ptr = ptr->next; }
    };
};
```

Все контейнеры имеют функции, которые возвращают итераторы на первый элемент и на элемент, следующий за последним:
```c++
vector<int> v;
vector<int>::iterator begin = v.begin();
vector<int>::iterator end_ = v.end();
```

Для `vector` и `deque` реализована арифметика, аналогичная арифметике указателей:
```c++
int i = *( v.begin() + 5 )
```

Проход по контейнеру (у list нет `operator[]`):
```c++
list<int> l;
list<int>::iterator it = l.begin();
for ( ; it != l.end(); ++it) {
    cout << *it;
}
```
Следующий итератор не позволяет менять данные, на которые он указывает:
```c++
list<int>::const_iterator cit = l.begin();
```

Поговорим про insert и erase и про то, как они влияют на итератор:
```c++
vector<int> v;
it = v.erase(it); // Удаление элемента, на который указывает итератор it

it = v.insert(it, 6) // Вставка цифры 6 на позицию, на которую указывает итератор it
```
А зачем эти методы возвращают iterator? С контейнером произвели операцию и теперь итераторы указывают в неверное место, поэтому `erase` и `insert` возвращают правильные относительно новых данных итераторы.

Замечание: "На который указывает" имеется в виду: "начало первого байта элемента"

Научимся перед каждым четным элементом вектора вставлять 0:
```c++
vector<int> v;

for (vector<int>::iterator i = v.begin(); i != v.end(); ++i) {
    if (*i % 2 == 0) {
        i = v.insert(i, 0);
        
        // При вставке может произойти перераспределение памяти, 
        // а insert() возвращает итератор на только что 
        // вставленный элемент
        ++i;
    }
}
```